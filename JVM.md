## JVM

### 编译、运行基本流程

Java程序从源文件创建到程序运行要经过两大步骤：
1、源文件由编译器编译成字节码（ByteCode）
2、字节码由java虚拟机解释运行。
因为java程序既要编译也要经过JVM的解释运行，所以说Java被称为半解释语言.

#### java源码编译机制

词法分析、语法分析、语义分析、字节码生成器  ——  将源码分析和输入到符号表、注解处理、语义分析和生成class文件

#### 类加载机制

通过ClassLoader及其子类来完成的，使用了双亲委托模型，即子类的类加载器找不到，就会找父类的加载，直到BootstrapClassLoader，它是用c语言写的，没有父类

1）Bootstrap ClassLoader

负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类

2）Extension ClassLoader

负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包

3）App ClassLoader

负责记载classpath中指定的jar包及目录中class

4）Custom ClassLoader

属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader

加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。

#### 类执行机制

JVM是基于栈的体系结构来执行class字节码的。线程创建后，都会产生程序计数器（PC）和栈（Stack），程序计数器存放下一条要执行的指令在方法内的偏移量，栈中存放一个个栈帧，每个栈帧对应着每个方法的每次调用，而栈帧又是有局部变量区和操作数栈两部分组成，局部变量区用于存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程中产生的中间结果。栈的结构如下图所示：

### Classloader

1）Bootstrap ClassLoader

负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类

2）Extension ClassLoader

负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包

3）App ClassLoader

负责记载classpath中指定的jar包及目录中class

4）Custom ClassLoader

属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader

### Class和dex文件结构

- ***\*记录一个类文件的所有信息，记住是所有！\****包括一个类的名称、类中所有的方法、类中所有的变量等等，class文件中所包含的信息，远远多于java源代码中所能看到的信息。

1、内存占用大，不合适移动端：每一个class文件包括很多的常量池，以及所有的field、method，而我们一个应用中有成百上千个类，是非常常见的，如果单纯的使用class字节码这种文件去存储类的信息的话，那么在移动端是不现实的，因为移动端的内存是非常少的。

2、堆栈的加载模式，加载速度慢；

3、文件IO操作多，类查找和加载慢：每个class文件只存储了一个java源文件中的所有的信息，每次去加载一个新的class的时候，都要去执行一遍加载查询，所以相对来说查找较慢。



- dex文件记录整个工程中所有类文件的信息，记住是整个工程！

本质上它们都是一样的，dex文件是从class文件演变而来的 

class文件存在许多冗余信息，dex会去除冗余并整合



### 内存模型、内存管理、GC

### Java对象生命周期

#### 1、Created（创建）

Java对象的创建分为如下几步：

- 1、为对象分配存储空间。
- 2、构造对象。
- 3、从超类到子类对static成员进行初始化，类的static成员的初始化在ClassLoader加载该类时进行。
- 4、超类成员变量按顺序初始化，递归调用超类的构造方法。
- 5、子类成员变量按顺序初始化，一旦对象被创建，子类构造方法就调用该对象并为某些变量赋值。

#### 2、InUse（应用）

此时对象**至少被一个强引用持有**。

#### 3、Invisible（不可见）

当一个对象处于不可见阶段时，说明程序本身不再持有该对象的任何强引用，虽然该对象仍然是存在的。简单的例子就是**程序的执行已经超出了该对象的作用域**了。但是，该对象**仍可能被虚拟机下的某些已装载的静态变量线程或JNI等强引用持有**，这些**特殊的强引用称为“GC Root”**。**被这些GC Root强引用的对象会导致该对象的内存泄漏，因而无法被GC回收**。

#### 4、Unreachable（不可达）

该对象**不再被任何强引用持有**。

#### 5、Collected（收集）

当**GC已经对该对象的内存空间重新分配做好准备**时，对象进入收集阶段，如果该对象重写了finalize()方法，则执行它。

#### 6、Finalized（终结）

**等待垃圾回收器回收该对象空间**。

#### 7、Deallocated（对象空间重新分配）

GC对该对象所占用的内存空间**进行回收或者再分配**，则该对象彻底消失。

#### 注意

- 1、不需要使用该对象时，及时置空。
- 2、访问本地变量优于访问类中的变量。



### Java内存分配模型

JVM 将整个内存划分为了几块，分别如下所示：

- 1）、方法区：存储类信息、常量、静态变量等。=> 所有线程共享
- 2）、虚拟机栈：存储局部变量表、操作数栈等。
- 3）、本地方法栈：不同与虚拟机栈为 Java 方法服务、它是为 Native 方法服务的。
- 4）、堆：内存最大的区域，每一个对象实际分配内存都是在堆上进行分配的，，而在虚拟机栈中分配的只是引用，这些引用会指向堆中真正存储的对象。此外，堆也是垃圾回收器（GC）所主要作用的区域，并且，内存泄漏也都是发生在这个区域。=> 所有线程共享
- 5）、程序计数器：存储当前线程执行目标方法执行到了第几行。



### Android内存分配模型

在Android系统中，**堆**实际上就是一块**匿名共享内存**。Android虚拟机仅仅只是把它封装成一个 **mSpace**，**由底层C库来管理**，并且**仍然使用libc提供的函数malloc和free来分配和释放内存**。

大多数静态数据会被**映射**到一个**共享的进程**中。常见的**静态数据包括Dalvik Code、app resources、so文件**等等。

在大多数情况下，Android通过显示分配共享内存区域（如Ashmem或者Gralloc）来实现动态RAM区域能够在不同进程之间共享的机制。例如，**Window Surface在App和Screen Compositor之间使用共享的内存，Cursor Buffers在Content Provider和Clients之间共享内存**。

上面说过，对于Android Runtime有两种虚拟机，Dalvik 和 ART，它们**分配的内存区域块是不同的**，下面我们就来简单了解下。

### Dalvik

- **Linear Alloc**
- **Zygote Space**
- **Alloc Space**

### ART

- **Non Moving Space**
- **Zygote Space**
- **Alloc Space**
- **Image Space**
- **Large Obj Space**

不管是Dlavik还是ART，**运行时堆都分为 LinearAlloc（类似于ART的Non Moving Space）、Zygote Space 和 Alloc Space**。Dalvik中的Linear Alloc是一个线性内存空间，是一个只读区域，主要用来存储虚拟机中的类，因为类加载后只需要只读的属性，并且不会改变它。把这些**只读属性**以及**在整个进程的生命周期都不能结束的永久数据**放到**线性分配器中管理**，能很好地**减少堆混乱和GC扫描，提升内存管理的性能**。**Zygote Space在Zygote进程和应用程序进程之间共享，Allocation Space则是每个进程独占**。Android系统的第一个虚拟机由Zygote进程创建并且只有一个Zygote Space。但是当Zygote进程在fork第一个应用程序进程之前，会将已经使用的那部分堆内存划分为一部分，还没有使用的堆内存划分为另一部分，也就是Allocation Space。**但无论是应用程序进程，还是Zygote进程，当他们需要分配对象时，都是在各自的Allocation Space堆上进行**。

当在ART运行时，还有另外两个区块，即 **ImageSpace和Large Object Space**。

- **Image Space**：**存放一些预加载类**，类似于Dalvik中的Linear Alloc。与**Zygote Space**一样，**在Zygote进程和应用程序进程之间共享**。
- **Large Object Space**：**离散地址的集合，分配一些大对象，用于提高GC的管理效率和整体性能**。

**注意**：Image Space的对象只创建一次，而Zygote Space的对象需要在系统每次启动时，根据运行情况都重新创建一遍。



### Java内存回收算法

#### 1）、标记-清除算法

实现原理

- 标记出所有需要回收的对象。
- 统一回收所有被标记的对象。

特点

- 标记和清除效率不高。
- 产生大量不连续的内存碎片。

#### 2）、复制算法

实现原理

- 将内存划分为大小相等的两块。
- 一块内存用完之后复制存活对象至另一块。
- 清理另一块内存。

特点

- 实现简单，运行高效。
- 浪费一半空间，代价大。

#### 3）、标记-整理算法

实现原理

- 标记过程与 ”标记-清除“ 算法一样。
- 存活对象往一端进行移动。
- 清理其余内存。

特点

- 避免 ”标记-清除” 算法导致的内存碎片。
- 避免复制算法的空间浪费。

#### 4）、分代收集算法（大多数虚拟机厂商所选用的算法）

特点

- 结合多种收集算法的优势。
- 新生代对象存活率低 => “复制” 算法（注意这里每一次的复制比例都是可以调整的，如一次仅复制 30% 的存活对象）。
- 老年代对象存活率高 => “标记-整理” 算法。

### Android内存回收机制

对于 Android 设备来说，我们每打开一个 APP，它的内存都是弹性分配的，并且其分配值与最大值是受具体设备而定的。

此外，我们需要注意区分如下两种 OOM 场景：

- 1）、内存真正不足：例如 APP 当前进程最大内存上限为 512 MB，当超过这个值就表明内存真正不足了。
- 2）、可用内存不足：手机系统内存极度紧张，就算 APP 当前进程最大内存上限为 512 MB，我们只分配了 200 MB，也会产生内存溢出，因为系统的可用内存不足了。

在Android的高级系统版本中，针对Heap空间有一个Generational Heap Memory的模型，其中将整个内存分为三个区域：

- **Young Generation（年轻代）**
- **Old Generation（年老代）**
- **Permanent Generation（持久代）**

模型示意图如下所示：

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d65535569570482aaa9a1da747abe27f~tplv-k3u1fbpfcp-zoom-1.image)



#### 1、Young Generation

由**一个Eden区和两个Survivor区**组成，程序中生成的**大部分新的对象都在Eden区**中，**当Eden区满时，还存活的对象将被复制到其中一个Survivor区，当此Survivor区满时，此区存活的对象又被复制到另一个Survivor区，当这个Survivor区也满时，会将其中存活的对象复制到年老代**。

#### 2、Old Generation

一般情况下，年老代中的对象**生命周期都比较长**。

#### 3、Permanent Generation

用于**存放静态的类和方法**，持久代对垃圾回收没有显著影响。（在 JDK 1.8 及之后的版本，在本地内存中实现的元空间（Meta-space）已经代替了永久代）

#### 4、内存对象的处理过程小结

- 1、**对象创建后在Eden区**。
- 2、**执行GC后，如果对象仍然存活，则复制到S0区**。
- 3、**当S0区满时，该区域存活对象将复制到S1区，然后S0清空，接下来S0和S1角色互换**。
- 4、**当第3步达到一定次数（系统版本不同会有差异）后，存活对象将被复制到Old Generation**。
- 5、**当这个对象在Old Generation区域停留的时间达到一定程度时，它会被移动到Old Generation，最后累积一定时间再移动到Permanent Generation区域**。

系统在Young Generation、Old Generation上采用不同的回收机制。每一个Generation的内存区域都有固定的大小。随着新的对象陆续被分配到此区域，**当对象总的大小临近这一级别内存区域的阈值时，会触发GC操作，以便腾出空间来存放其他新的对象**。

此外，执行GC占用的时间与Generation和Generation中的对象数量有关，如下所示：

- **Young Generation < Old Generation < Permanent Generation**
- **Generation中的对象数量与执行时间成反比**。

#### 5、Young Generation GC

由于其对象存活时间短，因此基于**Copying算法**（扫描出存活的对象，并复制到一块新的完全未使用的控件中）来回收。新生代采用**空闲指针的方式来控制GC触发，指针保持最后一个分配的对象在Young Generation区间的位置，当有新的对象要分配内存时，用于检查空间是否足够，不够就触发GC**。

#### 6、Old Generation GC

由于其对象存活时间较长，比较稳定，因此采用**Mark（标记）算法**（扫描出存活的对象，然后再回收未被标记的对象，回收后对空出的空间要么合并，要么标记出来便于下次分配，以减少内存碎片带来的效率损耗）来回收。

#### 7、Dalvik 与 ART 区别

- 1）、Dalivk 仅固定一种回收算法。
- 2）、ART 回收算法可运行期选择。
- 3）、ART 具备内存整理能力，减少内存空洞。

### GC类型

在Android系统中，GC有三种类型：

- **kGcCauseForAlloc**：分配内存不够引起的GC，会Stop World。由于是并发GC，其它线程都会停止，直到GC完成。
- **kGcCauseBackground**：内存达到一定阈值触发的GC，由于是一个后台GC，所以不会引起Stop World。
- **kGcCauseExplicit**：显示调用时进行的GC，当ART打开这个选项时，使用System.gc时会进行GC。

接下来，我们来学会如何分析Android虚拟机中的GC日志，日志如下：

```
D/dalvikvm(7030)：GC_CONCURRENT freed 1049K, 60% free 2341K/9351K, external 3502K/6261K, paused 3ms 3ms
复制代码
```

GC_CONCURRENT 是当前GC时的类型，GC日志中有以下几种类型：

- **GC_CONCURRENT**：当应用程序中的Heap内存占用上升时（分配对象大小超过384k），避免Heap内存满了而触发的GC。如果发现有大量的GC_CONCURRENT出现，说明应用中**可能一直有大于384k的对象被分配，而这一般都是一些临时对象被反复创建**，可能是**对象复用不够所导致的**。
- **GC_FOR_MALLOC**：这是由于Concurrent GC没有及时执行完，而应用又需要分配更多的内存，这时不得不停下来进行Malloc GC。
- **GC_EXTERNAL_ALLOC**：这是为external分配的内存执行的GC。
- **GC_HPROF_DUMP_HEAP**：创建一个HPROF profile的时候执行。
- **GC_EXPLICIT**：显示调用了System.GC()。（尽量避免）

我们再回到上面打印的日志:

- **freed 1049k**：表明在这次GC中回收了多少内存。
- **60% free 2341k/9351K**：表明回收后60%的Heap可用，存活的对象大小为2341kb，heap大小是9351kb。
- **external 3502/6261K**：是Native Memory的数据。**存放Bitmap Pixel Data（位图数据）或者堆以外内存（NIO Direct Buffer）之类的数据**。第一个值说明在Native Memory中已分配3502kb内存，第二个值是一个浮动的GC阈值，当分配内存达到这个值时，会触发一次GC。
- **paused 3ms 3ms**：表明GC的暂停时间，如果是Concurrent GC，会看到两个时间，一个开始，一个结束，且时间很短，如果是其他类型的GC，很可能只会看到一个时间，且这个时间是相对比较长的。并且，越大的Heap Size在GC时导致暂停的时间越长。

**注意**：在ART模式下，多了一个**Large Object Space**，这部分内存**并不是分配在堆上，但还是属于应用程序的内存空间**。

**在Dalvik**虚拟机下，GC的操作都是**并发**的，也就意味着每次触发GC都会导致其它线程**暂停**工作（包括UI线程）。而在**ART**模式下，GC时不像Dalvik仅有一种回收算法，ART**在不同的情况下会选择不同的回收算法**，比如**Alloc内存不够时会采用非并发GC，但在Alloc后，发现内存达到一定阈值时又会触发并发GC**。所以在ART模式下，并不是所有的GC都是非并发的。

总体来看，在GC方面，与Dalvik相比，ART更为高效，不仅仅是GC的效率，大大地缩短了Pause时间，而且在内存分配上对大内存分配单独的区域，还能有算法在后台做内存整理，减少内存碎片。因此，在ART虚拟机下，可以避免较多的类似GC导致的卡顿问题。



### Low Memory Killer机制

LMK 机制是针对于手机系统所有进程而制定的，当我们手机内存不足的情况下，LMK 机制就会针对我们所有进程进行回收，而其对于不同的进程，它的回收力度也是有不同的，目前系统的进程类型主要有如下几种：

- 1）、前台进程
- 2）、可见进程
- 3）、服务进程
- 4）、后台进程
- 5）、空进程

从前台进程到空进程，进程优先级会越来越低，因此，它被 LMK 机制杀死的几率也会相应变大。此外，LMK 机制也会综合考虑回收收益，这样就能保证我们大多数进程不会出现内存不足的情况。



#### 内存结构

- 堆内存：线程共享，存放对象实例，几乎所有对象实例都在堆分配内存，Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“**GC堆**”。

 可细分为年轻代和老年代，年轻代可细分为Eden空间，From survivor空间和To survivor空间

根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。

如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。

- 方法区

方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，**它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。**虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。

- JVM栈

与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，**它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：**每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。**每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。**

- 本地方法栈

本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而**本地方法栈则是为虚拟机使用到的Native方法服务。**虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。

- 程序计数器——为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。

如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。

#### GC

两种判断对象是否存活

四种gc算法

### AOT、JIT

运行前编译和运行时编译

在android里面，jit会把程序实时编译为机器字节码，然后虚拟机读取，打开程序～而aot是在安装的时候预先打包好了字节码放在手机内部储存里面，打开程序直接读取预先打包好的玩意就可以了……优缺点就很明显了吧？jit打开时干了那么多事情，速度必定比较慢，aot直接读取比较快咯

JIT：吞吐量高，有运行时性能加成，可以跑得更快，并可以做到动态生成代码等，但是相对启动速度较慢，并需要一定时间和调用频率才能触发 JIT 的分层机制

AOT：内存占用低，启动速度快，可以无需 runtime 运行，直接将 runtime 静态链接至最终的程序中，但是无运行时性能加成，不能根据程序运行情况做进一步的优化

### dalvik、ART

（1）在Dalvik下，应用每次运行都需要通过即时编译器（JIT）将字节码转换为机器码，即每次都要编译加运行，这虽然会使安装过程比较快，但是会拖慢应用以后每次启动的效率。而在ART 环境中，应用在第一次安装的时候，字节码就会预编译（AOT）成机器码，这样的话，虽然设备和应用的首次启动（安装慢了）会变慢，但是以后每次启动执行的时候，都可以直接运行，因此运行效率会提高。

（2）ART占用空间比Dalvik大（字节码变为机器码之后，可能会增加10%-20%），这也是著名的“空间换时间大法"。

（3）预编译也可以明显改善电池续航，因为应用程序每次运行时不用重复编译了，从而减少了 CPU 的使用频率，降低了能耗。 

### 并发实现（轻量级锁、偏向锁、monitor、synchronized原理）

synchronized的实现原理：每个对象有个monitor，monitor为0，线程进入该monitor，将monitor置为1,作为该monitor的所有者;如果已经占有，再次进入则再加一，这是可重入锁的实现;如果被别的线程占据，则该线程堵塞，直到monitor为0

监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因



轻量级锁：轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。

偏向锁：引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的CAS原子指令的性能消耗）。上面说过，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。